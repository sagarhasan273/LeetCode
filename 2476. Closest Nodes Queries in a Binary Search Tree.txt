Python 03:

class Solution:
    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:
        answer = []
        
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            answer.append(root.val)
            dfs(root.right)
        
        dfs(root)
        res = []

        l = len(answer)
        
        for q in queries:
            lo = 0
            hi = l-1
            flag = False
            while hi - lo > 1:
                mid = lo + (hi - lo) // 2
                if answer[mid] < q:
                    lo = mid
                elif answer[mid] > q:
                    hi = mid
                else:
                    flag = True
                    break;

            if flag:
                res.append([q, q])
            elif answer[0] > q:
                res.append([-1, answer[0]])
            elif answer[l-1] < q:
                res.append([answer[l-1], -1])
            elif answer[lo] == q:
                res.append([answer[lo], answer[lo]])
            elif answer[hi] == q:
                res.append([answer[hi], answer[hi]])
            else:
                res.append([answer[lo], answer[hi]])
        
        return res


C++ solution:

class Solution {
public:
    
    int lower_bound(vector<int> &arr, int target){
        int l = 0, r = arr.size()-1, mid = -1;
        
        while (l <= r){
            mid = l + (r-l)/2;
            
            if (arr[mid] <= target){
                l = mid + 1;
            }else{
                r = mid - 1;
            }
        }
        
        return r;
    }
    
    int upper_bound(vector<int> &arr, int target){
        int l = 0, r = arr.size()-1, mid;
        
        while (l <= r){
            mid = l + (r-l)/2;
            
            if (arr[mid] >= target){
                r = mid - 1;
            }else{
                l = mid + 1;
            }
        }
        
        return l;
    }
    
    void inOrderTraversal(TreeNode* root, vector<int>& arr){
        if (!root) return;
        
        inOrderTraversal(root->left, arr);
        arr.push_back(root->val);
        inOrderTraversal(root->right, arr);
    }
    
    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
        vector<int> numbers;
        
        inOrderTraversal(root, numbers);
        
        vector<vector<int>> result;
        int l = numbers.size();
        
        for(int i = 0; i < queries.size(); i++){
            int q = queries[i];
            int x = lower_bound(numbers, q);
            int y = upper_bound(numbers, q);
            
            if (x >= 0 && x < l && numbers[x] <= q) x = numbers[x];
            else x = -1;
            
            if (y >= 0 && y < l && numbers[y] >= q) y = numbers[y];
            else y = -1;
            
            result.push_back({x, y});
        }
        
        return result;
    }
};